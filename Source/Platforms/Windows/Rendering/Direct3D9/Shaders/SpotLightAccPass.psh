sampler2D GBufferPosition: register(s0);
sampler2D GBufferNormals: register(s1);
float4 texCoordsAdjustment: register(c0);
float4 unprojectionVector: register(c1);
float4 projectionParameters: register(c2);

struct PS_INPUT
{
        float4 LightColor: TEXCOORD0;
        float4 LightPosition: TEXCOORD1;
        float4 LightDirection: TEXCOORD2;
        float4 textureCoords: TEXCOORD3;
};

float4 main(PS_INPUT In): COLOR0
{
        // compute tex coords
        In.textureCoords.xy /= In.textureCoords.w;
        // map texels to pixels
        In.textureCoords.xy += texCoordsAdjustment.xy;
        float2 TC = 0.5f * (float2(In.textureCoords.x, -In.textureCoords.y) + 1.0);

        float4 ns = tex2D(GBufferNormals, TC);
        ns.w *= 200.0;
        // restore position in view space
        float3 p = DecodePos(tex2D(GBufferPosition, TC), In.textureCoords.xy, projectionParameters, unprojectionVector);
        float3 n = normalize(DecodeNormal(ns.xyz));
        float3 ToLight = In.LightPosition.xyz - p;
        float3 ToLightNrm = normalize(ToLight);
        float3 LightDir = normalize(In.LightDirection.xyz);
        float Factor = 1.0 - dot(ToLightNrm, LightDir);
        float Att = clamp(1.0 - Factor * Factor * In.LightDirection.w, 0.0, 1.0);
        Att = min(Att, clamp(1.0 - dot(ToLight, ToLight) * In.LightPosition.w, 0.0, 1.0));

        float3 v = normalize(-p);
        float3 h = normalize(ToLightNrm + v);
        float NL = dot(n, ToLightNrm) * Att;

        return float4((In.LightColor.xyz * NL * In.LightColor.w), NL * pow(dot(n, h), ns.w));
}
